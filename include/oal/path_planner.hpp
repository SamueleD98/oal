#ifndef PATH_PLANNER_HPP
#define PATH_PLANNER_HPP

#include <iostream>
#include <fstream>
#include <memory>
#include <stack>
#include <set>
#include <iomanip> //tables
#include <eigen3/Eigen/Eigen>
#include "oal/data_structs/misc.hpp"
#include "oal/helper_functions.hpp"

#define MAX_TIME 10000
#define HeadOnAngle (15*(M_PI/180))
#define OvertakingAngle (112*(M_PI/180))
//#define acceptanceRadius (5)

class path_planner {
private:
    VehicleInfo v_info_;
    ObstaclesInfo obss_info_;
    bool colregs_compliance;
    double acceptanceRadius;

    std::vector<std::string> noCrossList;

    std::ofstream plotWpsFile_;
    std::ofstream plotCKFile_;

    // Given some obstacle vertexes, find (if they exist) the points where they are intercepted by own ship
    void FindInterceptPoints(const Node &start, Obstacle &obstacle, double vh_speed,
                             std::vector<Vertex> visible_vxs_abs, std::vector<Vertex>& reachable_vxs);

    // Given a bb side (2 vxs), finds where a vector from start to goal collides with the plane generated by the bb side and direction
    static bool FindLinePlaneIntersectionPoint(Vertex vx1, Vertex vx2, const Eigen::Vector3d &bb_direction,
                                               const Node &start, const Node &goal,
                                               Eigen::Vector3d &collision_point);

    // Check if a point is in any obs bb at given time (and save such obs in vector if its pointer is given)
    bool IsInAnyBB(TPoint time_point, const std::shared_ptr<std::vector<obs_ptr>> &surrounding_obs = nullptr);

    // Check if starting position is safe or find new start positions. Insert them in set
    bool RootSetup(const Eigen::Vector2d &goal_position, std::multiset<Node> &open_set);

    // Check if path between nodes is colregs compliant
    bool CheckColreg(const Node &start, Node &goal) const;

    // Check if path between nodes collide with any obstacle (and save such points in vector if its pointer is given)
    bool
    CheckCollision(const Node &start, Node &goal, const std::shared_ptr<std::vector<Node>> &collision_points = nullptr);

    // Check the final path to goal. If goal is unreachable only because it is in an obs bb, finds new goal outside it
    bool CheckFinal(const Node &start, Node goal, std::multiset<Node> &open_set, std::multiset<Node> &reachable_full_set);

    // Order waypoints in a stack by going backward from the goal to start using the parent pointer attribute
    void BuildPath(Node &goal, Path &path);

    // Compute local vxs depending on ownship position wrt each of them. If true is passed then add a pre-defined gap to vxs dimension
    void FindObssLocalVxs(bool with_uncertainty);

    double GetHighestSpeed(){
      return *std::max_element(std::begin(v_info_.velocities), std::end(v_info_.velocities));
    }

public:
    // vehicle start position and obstacles information are supposed to be taken in the same time instant.
    path_planner() = default;

    path_planner(VehicleInfo v_info, const std::vector<Obstacle>& obstacles, double acc_radius)
            : v_info_(std::move(v_info)) {
      colregs_compliance = false;
      acceptanceRadius = acc_radius;
      for(const auto& obs : obstacles){
        obss_info_.obstacles.push_back(std::make_shared<Obstacle>(obs));
      }

      // Plot stuff
      {
        if (plotCKFile_.is_open()) plotCKFile_.close();
        plotCKFile_.open("CKlog.txt", std::ofstream::trunc);
      }
    }

    // Compute the path to reach the goal and fills the path's waypoints stack
    bool ComputePath(const Eigen::Vector2d &goal, bool colregs, Path &path);

    // Given a trajectory, checks if it's safe
    bool CheckPath(const Eigen::Vector2d &vh_pos, Path path);

    void SetVhData(VehicleInfo v_info) {
      v_info_ = std::move(v_info);
    }

    void SetObssData(const std::vector<Obstacle>& obstacles) {
      obss_info_.obstacles.clear();
      for(const auto& obs : obstacles){
        obss_info_.obstacles.push_back(std::make_shared<Obstacle>(obs));
      }
    }

    void SetAccRadius(double acc_radius){
      acceptanceRadius = acc_radius;
    }

    void print(Eigen::Vector2d goal) const{
      auto printVector = [](const std::vector<double>& vec, const std::string& sep = ",") {
          auto last = vec.end() - 1;
          for (auto it = vec.begin(); it != vec.end(); ++it) {
            std::cout << *it;
            if (it != last) {
              std::cout << sep;
            }
          }
      };

      std::cout<< "-----------------------\n"
               << " Vehicle data:\n"
               << "  colregs = "<<colregs_compliance<<";\n"
               << "  v_info.position = {"<<v_info_.position.x()<<", "<<v_info_.position.y()<<"};\n"
               << "  v_info.heading = {"<<v_info_.heading<<"};\n"
               << "  v_info.velocities = {"; printVector(v_info_.velocities) ; std::cout << "};\n"
               << "  goal = {"<<goal.x()<<", "<<goal.y()<<"};\n"
               << "  bb_data bb_dimension;\n";

      for(const auto& obs: obss_info_.obstacles){
        std::cout<< " bb_dimension = bb_data("<<obs->bb.dim_x<<", "<<obs->bb.dim_y<<", \n"
                                             <<obs->bb.max_x_bow<<", "<<obs->bb.max_x_stern<<", \n"
                                             <<obs->bb.max_y_starboard<<", "<<obs->bb.max_y_port<<", \n"
                                             <<obs->bb.safety_x_bow<<", "<<obs->bb.safety_x_stern<<", \n"
                                             <<obs->bb.safety_y_starboard<<", "<<obs->bb.safety_y_port<<", \n"
                                             <<obs->bb.gap<<");\n";
        std::cout<< " obstacles.push_back(Obstacle(\""<<obs->id<<"\", {"
                                                     <<obs->position.x()<<", "<<obs->position.y()<<"}, "
                                                     <<obs->head<<", "<<obs->speed<<", "<<obs->vel_dir<<", bb_dimension));\n";

      }
    }
};

#endif
